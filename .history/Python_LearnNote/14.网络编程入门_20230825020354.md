# 网络编程入门

## 计算机网络基础

计算机网络是独立自主的计算机互联而成的系统的总称，组件计算机网络最主要的目的是实现多台计算机之间的通信和资源共享。

### OSI七层模型

OSI模型的目的是规范不同系统的互联标准，使两个不同的系统能够较容易的通信，而不需要改变底层的硬件或软件的逻辑。
OSI模型的优点：

+ 将网络的通信过程划分为小且简单的部件，因此有助于各个部件的开发、设计和故障排除
+ 通过网络组件的标准化，允许多个供应商进行开发
+ 通过定义在模型的每一层实现什么功能，鼓励产业的标准化
+ 允许各类型的网络硬件和软件之间相互通信
+ 防止对某一层所做的改动影响到其他层
  
OSI七层模型按照功能划分为七层，分别是：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
他们的功能如下图所示：
![OSI七层模型](../img/OSI.png)
特点：

+ OSI模型每层都有自己的功能
+ 层与层之间相互独立又相互依靠
+ 上层依赖于下层，下层服务于上层

### TCP/IP四层模型

实现网络通信的基础是网络通信协议，这些协议通常是由IETF指定的。网络协议的三要素是：语法、语义和时序。语法是指数据与控制信息的结构或格式。语义是指需要发出何种控制信息以及完成何种动作。时序是指事件发生的顺序。构成我们今天使用的Internet的基础的是TCP/IP协议族，所谓协议族就是一系列的协议及其构成的通信模型，我们通常也把这套东西成为TCP/IP模型。该模型将我们使用的网络从逻辑上分解为四个层次，分别是：网络接口层、网络层、传输层、应用层。
![TCP/IP四层模型](../img/TCP-IP-model.png)
IP通常被反以为网际协议，他服务于网络层，主要实现了寻址和路由的功能。介入网络的每一台主机都需要有自己的IP地址，IP地址就是主机在计算机网络上的身份标识。当然由于IPV4地址的匮乏，我们平常在家里、办公室以及其他可以介入网络的公共区域上网时获得的IP地址并不是全球唯一的IP地址，而是局域网(LAN)中的内部IP地址，通过网络地址转换(NAT)技术，我们可以将内部IP地址转换为全球唯一的IP地址，从而实现了我们的上网需求。计算机网络上游大量被我们成为“路由器”的网络中继设备，它们会存储转化我们发送到网络上的数据分组，让源头发出的数据能够最终找到转送目的地的通路，这项功能就是所谓的路由。
IP协议负责将数据从一台计算机通过网络发送到另一台计算机。数据被分割成一小块一小块，然后通过IP包发送出去。由于互联网链路复杂，两台计算机之间经常有多天线路，因此，路由器就负责把一个IP包转发出去。IP包的特点是按块发送，途径多个路由，但不保证能到达，也不保证顺序到达。
TCP全称传输控制协议，它是基于IP提供的寻址和路由服务而建立起来的负责实现端到端可靠传输的协议，之所以将TCP成为可靠的传输协议是因为TCP向调用者承诺了三件事：

1. 数据不传丢不传错(利用握手、校验和重传机制可以实现)
2. 流量控制(通过滑动窗口匹配数据发送者和接受者之间的传输速度)
3. 拥塞控制(RTT时间以及对滑动窗口的控制环节网络拥堵)

TCP协议是建立在IP协议上的。TCP协议负责在两台计算机之间建立可靠连接，保证数据包按顺序到达。TCP协议会通过我手机案例，然后，对每个IP包编号，确保对方按顺序收到，如果包丢了，就自动重发。
一个TCP报文除了包含要传输的数据外，还包含源IP地址和目标IP地址，源端口和目标端口。端口有什么用呢？在两台计算机通信时，只发IP地址是不够的，因为同一台计算机上跑着多个网络程序。一个TCP报文来了之后，到底是交给浏览器还是交给邮件程序，就需要端口号来区分。每个网络程序都向操作系统申请唯一的端口号，这样，两个进程在两台计算机之间建立网络连接就需要各自的IP地址和各自的端口号。

#### TCP编程

Socket是网络编程的一个抽象概念。通常我们用一个Socket表示“打开了一个网络链接”，而打开一个Socket需要知道目标计算机的IP地址和端口号，再指定协议类型即可。

##### TCP客户端

大多数链接都是可靠的TCP连接。创建TCP连接时，主动发起连接的叫客户端，被动响应链接的叫服务器。
举一个例子，当我们在浏览器中访问新浪网时，我们自己的计算机就是客户端，浏览器会主动向新浪的服务器发起连接。如果一切顺利，新浪的服务器接受了我们的连接，一个TCP连接就建立起来的，后面的通信就是发送网页内容了。所以，我们要创建一个基于TCP连接的Socket，可以这样做：

```python
import socket
import ssl

# 创建一个socket:
s = ssl.wrap_socket(socket.socket())
# 建立连接:
s.connect(('www.sina.com.cn', 443))
s.send(b'GET / HTTP/1.1\r\nHost: www.sina.com.cn\r\nConnection: close\r\n\r\n')
buffer = []
while True:
    # 每次最多接收1k字节:
    d = s.recv(1024)
    if d:
        buffer.append(d)
    else:
        break
data = b''.join(buffer)
s.close()
header, html = data.split(b'\r\n\r\n', 1)
print(header.decode('utf-8'))
# 把接收的数据写入文件:
with open('sina.html', 'wb') as f:
    f.write(html)

```

创建`Socket`时，`AF_INET`指定使用IPv4协议，如果要用更先进的IPv6，就指定为`AF_INET6`。SOCK_STREAM指定使用面向流的TCP协议。
客户端要主动发起TCP连接，必须知道服务器的IP地址和端口号。

TCP连接建立的是双向通道，双方都可以给对方发数据。但是谁先发谁后发，怎么协调，要根据具体的协议来决定。例如，HTTP协议规定客户端必须先发请求给服务器，服务器收到后才发数据给客户端。发送的文本格式必须符合HTTP标准。

接受数据室，调用`recv(max)`方法，一次最多接收指定的字节数，因此，在一个while循环中反复接收，直到recv()返回空数据，表示接收完毕，退出循环。

当我们接收完数据后，调用`close()`方法关闭`Socket`，这样，一次完整的网络通信就结束了。

#### TCP 服务器

和客户端编程相比，服务器编程就要复杂一些。

服务器进程首先要绑定一个端口并监听来自其他客户端的连接。如果某个客户端连接过来了，服务器就与该客户端建立Socket连接，随后的通信就靠这个Socket连接了。

所以，服务器会打开固定端口（比如80）监听，每来一个客户端连接，就创建该Socket连接。由于服务器会有大量来自客户端的连接，所以，服务器要能够区分一个Socket连接是和哪个客户端绑定的。一个Socket依赖4项：服务器地址、服务器端口、客户端地址、客户端端口来唯一确定一个Socket。

但是服务器还需要同时响应多个客户端的请求，所以，每个连接都需要一个新的进程或者新的线程来处理，否则，服务器一次就只能服务一个客户端了。
我们来编写一个简单的服务器程序，它接收客户端连接，把客户端发过来的字符串加上Hello再发回去。

```python
import socket
import threading
import time


def tcplink(sock, addr):
    print('Accept new connection from %s:%s' % addr)
    sock.send(b'Welcome!')
    while True:
        data = sock.recv(1024)
        time.sleep(1)
        if not data or data.decode('utf-8') == 'exit':
            break
        sock.send(('Hello,%s!' % data.decode('utf-8')).encode('utf-8'))
    sock.close()
    print('Connection from %s:%s' % addr)


s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

s.bind(('127.0.0.1', 9999))
s.listen(5)
print('Waiting foe connection')
while True:
    sock, addr = s.accept()
    t = threading.Thread(target=tcplink, args=(sock, addr))
    t.start()

```
然后，我们要绑定监听的地址和端口。服务器可能有多块网卡，可以绑定到某一块网卡的IP地址上，也可以用0.0.0.0绑定到所有的网络地址，还可以用127.0.0.1绑定到本机地址。127.0.0.1是一个特殊的IP地址，表示本机地址，如果绑定到这个地址，客户端必须同时在本机运行才能连接，也就是说，外部的计算机无法连接进来。

端口号需要预先指定。因为我们写的这个服务不是标准服务，所以用9999这个端口号。请注意，小于1024的端口号必须要有管理员权限才能绑定.
紧接着，调用listen()方法开始监听端口，传入的参数指定等待连接的最大数量，接下来，服务器程序通过一个永久循环来接受来自客户端的连接，accept()会等待并返回一个客户端的连接，每个连接都必须创建新线程（或进程）来处理，否则，单线程在处理连接的过程中，无法接受其他客户端的连接。
要测试这个服务器程序，我们还需要编写一个客户端程序：

```python
import socket

s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(('127.0.0.1',9999))
print(s.recv(1024).decode('utf-8'))
for data in [b'Michael', b'Tracy',b'Sarah']:
    s.send(data)
    print(s.recv(1024).decode('utf-8'))

s.send(b'exit')
s.close()
```


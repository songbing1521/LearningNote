# CLASS IN C++

面向对象编程(OOP)是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了 C 语言，是的应用这种方法更容易。下面是最重要的 OOP 特性：

- 抽象
- 封装和数据隐藏
- 多态
- 集成
- 代码的可重用性

C++与其他语言的不同之处在于它不仅仅支持面向对象编程，还支持基于对象、面向过程、泛型编程。

简而言之，类是一种将数据和函数组织在一起的方式。在编程中，我们需要将所有想要的数据一次性包含，最终作为一个类型。由类类型制成的变量叫做对象，新创建对象的过程叫做实例化。

## 过程性编程和面向对象编程

采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑如何表示这些数据。
采用 OOP 方法时，首先从用户的角度出发考虑对象————描述对象所需的数据以及描述用户于数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据储存。最后，使用新的设计方案创建出程序。

## 抽象和类

首先要确定类型是什么，在指定基本类型是完成了三项工作：

- 决定数据对象需要的内存数量。
- 决定如何解释内存中的位(long 和 float 在内存中占用的位数相同，但将它们转换为数值的方法不同)
- 决定可使用数据对象执行的操作或方法

类是一种将抽象转换为用户定义类型的 C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。
类规范由两个部分组成：

- 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。
- 类方法定义：描述如何实现类成员函数。

简单的说，类声明提供了类的蓝图，而方法定义则提供了细节。
接口是一个共享框架，供两个系统交互时使用；对于类，我们说公共接口。在这里，公共时使用类的程序，交互系统由类对象组成，而接口由编写类的人提供方法组成。接口让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。

### 1.访问控制

关键字`private`和`public`也是新的，它们描述了对类成员的访问控制，使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数(或友元函数)来访问对象的私有成员。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++还提供了第三个访问控制关键字`protected`，第 13 章介绍类继承时将讨论该关键字。
类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将他们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现的细节隐藏在私有部分。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。
数据隐藏不仅可以防止直接访问数据，还让开发者(类的用户)无需了解数据是如何被表示的。从使用类的角度看，使用哪种方法没有什么区别。所需要的知道的是各种成员函数的功能；也就是说，需要知道成员函数接受什么样的参数以及返回什么类型的值。原则是将实现细节从接口设计中分离开来。如果以后找到了更好的。实现数据表示或成员函数细节的方法，可以对这些细节进行修改，二无需修改程序结构，这使得程序维护起来更容易。

### 2.控制对成员的访问：公有还是私有

无论类成员是数据成员还是成员函数都可以在类的公有部分还是私有部分声明他们，但数据封装是 OOP 的目标之一，一般将数据成员置于私有部分，将成员函数置于公有部分，但有时也将成员函数置于私有部分，通过公有函数将其定义。

### 3.类和结构的区别

实际上，C++中对结构进行了拓展，使之和类有相同的特性，但是结构中的数据成员和函数都是公有的，无法实现数据封装的作用。
类和结构唯一的区别是，结构的默认访问类型是 public，而类是 private。C++中常用类来实现描述，而把结构限制为只表示纯粹的数据对象。

## 实现类成员函数

我们在定义类中的数据成员以后，还需要创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，他们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：

- 定义函数成员时，使用作用域解析运算符(::)来指出函数所属的类。如：
  ```c++
  // update()成员函数的函数头定义如下：
  void Stock:: update()
  ```
- 类方法可以访问类的 private 组件

首先，成员函数的函数头使用作用域运算符解析`::`来指出函数所属的类。例如，`update()`成员函数的函数头如下：
`void Stock::update(double price)`
这种表示方法意味着我们定义的 update()函数是 Stock 类的成员。这不仅将 update()标识为成员函数，还意味着我们可以将另一个类的成员函数也命名成 update()。例如，Buffoon 类的 update()函数的函数头如下：
`void Buffoon::update()`
因此，作用域解析运算符确定了方法定义对应的类的身份。我们可以这样认为标识符`update()`具有类作用域(class scope)。Stock 类的其他成员函数不必使用作用域解析运算符，就可以使用 update()方法，这是因为他们属于用一个类，因此 update()是可见的。然而，在类声明和方法定义之外使用 update()时，需要采取特殊的措施。
类方法的完成名称中包括类名。我们说，`Stock::update()`是函数的限定名(qualified name);而简单的 update()是全名的缩写，他只能在类作用域中使用。
方法的第二个特点是，方法可以访问类的私有成员。

### 内联方法

其定义位于类声明中的函数都将自动成为内联函数，。类声明常将短小的成员函数作为内联函数。如果愿意，也可以在类声明之外定义成员函数，并使其成为内联函数。为此，只需在类实现部分中定义函数时使用`inline`限定符即可。
内联函数的特殊规则要求在每个使用它们的文件中都对其进行定义。取到内联定义对多文件程序中所有文件都可用的、最轻便的方法是：将内敛定义放在定义类的头文件中。
同时，根据改写规则，在类声明中定义方法等同于用原型替换方法定义，然后再类声明的后面将定义改写为内联函数。

### 一些其他的注意

调用成员函数时，他将使用被用来调用它的对象的数据成员。
所创建的每个新对象都有自己的存储空间，用于存储其内部变量和类成员；但同一个类的所有对象共享一组类方法，及每种方法只有一个副本。

### 使用类

在创建类对象时，可以声明类变量，也可以使用`new`来为类对象分配存储空间。可以将对象作为函数的参数和返回值，也可以将一个对象赋给另一个。

## 类的构造函数和析构函数

C++的目标之一就是像使用标准类型一样使用类对象。然而，到现在为止，我们并不能利用常规方法对类进行初始化。原因在于，类中的数据成员是私有的，只能够通过函数成员进行调用。所以我们需要设计合适的成员函数才能实现类的初始化。

### 声明和定义构造函数

现在需要创建 Stock 的构造函数。由于需要为 Stock 对象提供 3 个值，因此应为构造函数提供 3 个参数。因此，原型如下：

```cpp
Stack(const string& co, long n = 0, double pr = 0);
```

第一个参数是指向字符串的指针，该字符串用于初始化成员。n 和 pr 参数为成员提供返回值。注意，没有返回类型。原型位于类声明的公有部分。
下面是构造函数一种可能定义：

```cpp
Stock::Stock(const string & co, long n, double pr)
{
   company = co;
   fi(n < 0 ){
      std::cer << "Number of shares can't be negative";
      shares = 0;
   }esle{
      shares = n;
   }
   share_vale = pr;
   set_tot();
}
```

程序在声明对象时会自动调用构造函数。
在构造函数中，可以灵活运用`this`指针。.

### 使用构造函数

C++提供了两种构造函数来初始化对象的方式。第一种方式是显式地调用构造函数。

```cpp
Stock food = Stock("Furry mason", 50, 2.5);
```

另一种是隐式地调用构造函数：

```cpp
Stock garment("Furry Mason", 50, 2.5)
```

每次创建类对象(甚至使用 new 动态分配内存)时，C++都是用类构造函数。
下面是将构造函数与`new`一起使用的方法。

```cpp
Stock *pstock = new Stock("Electroshock Games"，18， 19.0)；
```

这种情况下，对象没有名称，但可以使用指针来管理该对象。
构造函数的使用方式不同于其他类方法，一般来说，使用对象来调用方法；但无法使用使用对象来调用构造函数，因为在构造函数构造出对象之前，对象时不存在的。因此构造函数被用来创建对象，而不能通过对象来调用。

### 默认构造函数

默认构造函数是在未提供显式初始值时，用来创建对象的构造函数。如果没有提供任何构造函数，则 C++将自动提供默认构造函数。他是默认构造函数的隐式版本，不做任何工作。如：

```cpp
Stock::Stock(){}
```

同时，我们要注意，当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数。为类定义了构造函数后，程序员就必须为它提供默认构造函数。如果提供了非默认构造函数，而没有提供默认构造函数，则声明将出错。
这样做的原因可能是想创建未初始化的对象。然而，如果要创建对象，而不显式地初始化，则必须定义一个不接受任何参数的默认构造函数。

## 析构函数

用构造函数创建对象后，程序负责跟踪对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数——析构函数。它将完成清理工作。例如，如果构造函数使用`new`来分配内存，则析构函数将使用`delete`来释放这些内存。析构函数不需要进行特定的定义，编译器将自己决定进行定义和调用。
如果创建的的是静态存储对象，则其析构函数将在程序结束时自动调用。如果创建的是自动存储类对象，则其析构函数将在程序执行完代码块时(该对象时在其中定义的)自动被调用。如果对象是通过 new 来创建的，则它将驻留在栈内存或自由存储区中，当使用 delete 来释放内存是，其析构函数将自动被调用。最后，程序可以创建临时对象来完成特定的操作，在这种情况下，程序将在结束对该对象的使用时自动调用其析构函数。
由于在类对象过期时析构函数将自动被调用，因此必须有一个析构汉书。如果程序员没有提供虚析构函数，编译器将隐式地声明一个默认析构函数，并在发现导致对象被删除的代码后，提供默认析构函数的定义。

## 构造函数和析构函数小结

构造函数是一种特殊的类成员函数，在创建类对象时被调用。构造函数的名称和类名相同，但但通过函数重载，可以创建多个同名的构造函数，条件是每个函数的特征标(参数列表)都不同。另外，构造函数没有声明类型。构造函数用于初始化类对象的成员。
在创建类对象的时候，如果没有显式地调用构造函数，那么将会调用默认构造函数。

对于析构函数，要注意的是，如果构造函数使用了`new`则必须提供使用`delete`的析构函数。

## this 指针

简单来说，每个成员函数(包括构造函数和析构函数)都有一个`this`指针，`this`指针指向用来调用函数成员的对象(`this`被作为隐藏参数传递给方法)。如果方法需要引用整个调用对象，则可以使用表达式`*this`。

## 对象数组

和之前的实例一样，用户通常要创建同一个类的的多个对象。可以创建对立独立对象变量，就像本章前面实例所做的，但创建对象数组将更合适。声明对象数组的方法，与声明标准类型数组相同：

```cpp
Stock mystuff[4]
```

前面讲过，当程序创建未被显式初始化的类对象时，总是调用默认构造函数。上述声明要求，这个类要么没有显式地定义任何构造函数(在这种情况下，将使用不执行任何操作的隐式默认构造函数)，要么定义了一个显式默认构造函数。
同时，我们可以用构造函数来初始化数组元素。在这种情况下，必须为每个元素调用构造函数：

```cpp
const int STKS = 4;
Stock stocks[STKS] = {
Stock{"NanoSmart", 12, 5, 20},
Stock{"Boffo Objects",200,2.0}
}
```

初始化对象数组的方案是，首先使用默认构造函数创建数组元素，然后花括号中的构造函数将创建临时对象，然后将临时对象的发内容复制到相应的元素中。因此，要创建类对象数组，则这个类必须由默认构造函数。

## 运算符重载

下面介绍一种使对象操作更美观的技术。运算符重载是一种形式的 C++多态。在之前介绍了 C++是如何使用户能够定义多个名称相同但特征标(参数列表)不同的函数的。这被称为函数重载或函数多态，旨在让你能够用同名的函数完成相同的操作，及时这种操作被用于不同的数据类型(想象一下，如果必须对不同的物体使用不同的东侧，这回显得多么笨拙)。运算符重载将重载的概念拓展到运算符上，允许赋予 C++运算符多种含义。实际上，很多 C++运算符已经被重载了。例如：`*`运算符用于地址，将得到存储记载这个地址上的值；但将她用于两个数字是，得到的是他们的乘积。C++根据操作数的熟么和类型来决定采用那种操作。
C++允许将运算符重载扩展到用户定义的类型，例如，允许使用+将两个对象相加。
重载运算符可使代码看起来更加自然。
要承载运算符，需使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：

```cpp
operatorop{argumen-list}
```

`op`必须是有效的 C++运算符，不能虚构一个新的符号。

### 重载限制

多数 C++运算符都可以用这样的方式重载。重载的运算符不必是成员函数，但必须至少是一个操作数是用户定义的类型。下面详细介绍 C++对用户定义的运算符重载的限制。

1. 重载后的运算符必须至少有一个操作数是用户定义的类型，这将防止用户为标准类型重载运算符。因此，不能将减法运算符重载为计算两个值的和，而不是他们的差。
2. 使用运算符时不能违反运算符原来的句法规则。同样不能修改运算符的优先级。
3. 不能创建新运算符。
4. 不能重载下面的运算符。
   - `sizeof`
   - `.`
   - `.*`
   - `:: `
   - `?:`
   - `typeid`
   - `const_cast`
   - `dynamic_cast`
   - `reinterpert_cast`
   - `static_cast`
5. 大多数运算符都可以通过成员或非成员函数进行重载，但下面的运算符只能通过成员函数进行重载。
   - `=`
   - `()`
   - `[]`
   - `->`

## 友元函数

通常，公有类方法提供唯一的访问途径，但是有的时候这种限制太严格，以至于不适合特定的编程问题。在这种情况下，C++提供了另一种形式的访问权限：友元。友元有 3 种：

- 友元函数
- 友元类
- 友元成员函数
  通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。在这一节将介绍友元函数，其他两种友元将在之后进行介绍。

### 创建友元

创建友元函数的第一步是将其原型放在类声明中，并在原型声明前加上关键字`friend`：

```cpp
friend Time operator*(double m , const Time& t);
```

该原型意味着下面两点：

- 虽然`operator*`函数是在类声明中声明的，但它不是成员函数，因此不能使用成员函数运算符来调用；
- 虽然`operator`函数不是成员函数，但它与成员函数的访问权限相同。

第二步是编写函数定义。虽然它不是成员函数，所以不要使用`Time::`限定符。另外，不要在定义中使用关键字`friend`。

### 友元是否有悖于 OOP

乍一看，可能会认为有缘违反了 OOP 数据隐藏的原则，因为友元机制允许非成员函数访问私有数据。然而，这个观点太片面了。相反，应将友元函数看做类的拓展接口的组成部分。通过使用友元函数和类方法，可以用用一个用户接口表达两种操作。另外请记住，只有类声明可以决定哪一个函数是友元，因此类声明仍然控制了那些函数可以访问私有数据。总之，类方法和友元只是表达类接口的两种不同机制。

### 类的自动转换和强制类型转换

在本章中，我们先复习一下 C++是如何处理内置类型转换的。将一个标准类型变量的值赋给另一种标准类型的变量时，如果这两种类型兼容，则 C++自动将这个值转换为接受变量的类型。
C++不自动转换不兼容的车型。
可以将类定义成与基本类型或另一个类相关，使得从一种类型转换为另一种类型是有意义的。在这种情况下，程序员可以指示 C++如何自动进行转换，或通过强制类型转换来完成。我们可以将构造函数用作自动转换函数。

```Cpp

```

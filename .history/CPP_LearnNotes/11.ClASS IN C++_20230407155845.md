# CLASS IN C++

面向对象编程(OOP)是一种特殊的、设计程序的概念性方法，C++通过一些特性改进了C语言，是的应用这种方法更容易。下面是最重要的OOP特性：

+ 抽象
+ 封装和数据隐藏
+ 多态
+ 集成
+ 代码的可重用性

C++与其他语言的不同之处在于它不仅仅支持面向对象编程，还支持基于对象、面向过程、泛型编程。

简而言之，类是一种将数据和函数组织在一起的方式。在编程中，我们需要将所有想要的数据一次性包含，最终作为一个类型。由类类型制成的变量叫做对象，新创建对象的过程叫做实例化。

## 过程性编程和面向对象编程

采用过程性编程方法时，首先考虑要遵循的步骤，然后考虑如何表示这些数据。
采用OOP方法时，首先从用户的角度出发考虑对象————描述对象所需的数据以及描述用户于数据交互所需的操作。完成对接口的描述后，需要确定如何实现接口和数据储存。最后，使用新的设计方案创建出程序。

## 抽象和类

首先要确定类型是什么，在指定基本类型是完成了三项工作：

+ 决定数据对象需要的内存数量。
+ 决定如何解释内存中的位(long和float在内存中占用的位数相同，但将它们转换为数值的方法不同)
+ 决定可使用数据对象执行的操作或方法

类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。
类规范由两个部分组成：

+ 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口。
+ 类方法定义：描述如何实现类成员函数。
  
简单的说，类声明提供了类的蓝图，而方法定义则提供了细节。
接口是一个共享框架，供两个系统交互时使用；对于类，我们说公共接口。在这里，公共时使用类的程序，交互系统由类对象组成，而接口由编写类的人提供方法组成。接口让程序员能够编写与类对象交互的代码，从而让程序能够使用类对象。

### 1.访问控制
关键字`private`和`public`也是新的，它们描述了对类成员的访问控制，使用类对象的程序都可以直接访问公有部分，但只能通过公有成员函数(或友元函数)来访问对象的私有成员。因此，公有成员函数是程序和对象的私有成员之间的桥梁，提供了对象和程序之间的接口。防止程序直接访问数据被称为数据隐藏。C++还提供了第三个访问控制关键字`protected`，第13章介绍类继承时将讨论该关键字。
类设计尽可能将公有接口与实现细节分开。公有接口表示设计的抽象组件。将实现细节放在一起并将他们与抽象分开被称为封装。数据隐藏(将数据放在类的私有部分中)是一种封装，将实现的细节隐藏在私有部分。封装的另一个例子是，将类函数定义和类声明放在不同的文件中。
数据隐藏不仅可以防止直接访问数据，还让开发者(类的用户)无需了解数据是如何被表示的。从使用类的角度看，使用哪种方法没有什么区别。所需要的知道的是各种成员函数的功能；也就是说，需要知道成员函数接受什么样的参数以及返回什么类型的值。原则是将实现细节从接口设计中分离开来。如果以后找到了更好的。实现数据表示或成员函数细节的方法，可以对这些细节进行修改，二无需修改程序结构，这使得程序维护起来更容易。
### 2.控制对成员的访问：公有还是私有
无论类成员是数据成员还是成员函数都可以在类的公有部分还是私有部分声明他们，但数据封装是OOP的目标之一，一般将数据成员置于私有部分，将成员函数置于公有部分，但有时也将成员函数置于私有部分，通过公有函数将其定义。
### 3.类和结构的区别
实际上，C++中对结构进行了拓展，使之和类有相同的特性，但是结构中的数据成员和函数都是公有的，无法实现数据封装的作用。
类和结构唯一的区别是，结构的默认访问类型是public，而类是private。C++中常用类来实现描述，而把结构限制为只表示纯粹的数据对象。

## 实现类成员函数
我们在定义类中的数据成员以后，还需要创建类描述的第二部分：为那些由类声明中的原型表示的成员函数提供代码。成员函数定义与常规函数定义非常相似，他们有函数头和函数体，也可以有返回类型和参数。但是它们还有两个特殊的特征：
+ 定义函数成员时，，使用作用域解析运算符(::)来实处函数所属的类。如：
   ```c++
   // update()成员函数的函数头定义如下：
   void Stock:: update()
   ```
+ 类方法可以访问类的private组件
  
首先，成员函数的函数头使用作用域运算符解析`::`来指出函数所属的类。例如，`update()`成员函数的函数头如下：
`void Stock::update(double price)`
这种表示方法意味着我们定义的update()函数是Stock类的成员。这不仅将update()标识为成员函数，还意味着我们可以将另一个类的成员函数也命名成update()。例如，Buffoon类的update()函数的函数头如下：
`void Buffoon::update()`
因此，作用域解析运算符确定了方法定义对应的类的身份。我们可以这样认为
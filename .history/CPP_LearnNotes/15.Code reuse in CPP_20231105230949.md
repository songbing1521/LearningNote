# C++中的代码重用

C++的一个主要目标是促进代码的重用。公有继承是实现这种目标的机制之一，但并不是唯一的机制。本章将介绍其他方法。

## 私有继承

使用私有继承，基类的公有成员和保护成员都将成为派生类的的私有成员。这意味着基类方法将不会成为派生类公有接口的一部分，但可以在派生类的成员函数中使用它们。使用私有继承，基类的公有方法将成为派生类的私有方法。总之，派生类不继承基类的接口。
保护继承是私有继承的变体，使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员。在使用保护继承时，与私有继承不同的是，第三代类可以使用基类的接口。
![继承权限](../img/jicheng2.png)
使用保护派生或私有派生时，基类的公有成员将成为保护成员或私有成员。假设要让基类的方法在派生类外面可用，方法之一是定义一个使用该基类方法的派生类方法，但多态的存在可能会造成冲突。我们可以使用`using`来指出派生类可以使用特定的基类成员。

## 保护继承

不再赘叙，具体位于14章。

## 多重继承

在代码的编写过程中，我们会发现需要这样的一种情况：一个类同时需要继承多个基类。同时，C++在引入多重继承的同时，引入了另一个概念：虚基类。虚基类是为了解决多重继承中的二义性问题而引入的。在多重继承中，如果派生类从多个基类继承了同一个基类，而这些基类又有共同的基类，那么在派生类中就会存在多个共同基类的同一个子对象，这就是二义性问题。为了解决这个问题，引入了虚基类的概念。虚基类是通过在继承列表中的基类名前加上关键字virtual来声明的。虚基类的作用是使得最终类中只包含一个共同的基类子对象，从而避免二义性。虚基类的子对象在最终类对象中只出现一次，因此虚基类子对象的构造函数只被调用一次，从而避免了二义性问题。虚基类使得从从多个类(具有共同基类)继承的派生类中，只继承一个共同基类。
形式如下：`class SingingWaiter:public Waiter, public Singer`，要注意的是公有多重继承必须使用关键字`public`，而私有多重继承则使用`private`，保护多重继承使用`protected`。`class SingingWaiter:public Waiter, SInger`singer为私有继承。

```cpp
Son::Son( 
 const char *lastName, const char *firstName,
 const char *food,
 const char *game)
 :Father(lastName, firstName), Mother(food)
{
 this->game = game;
}
```

MI(多重继承)

### 虚基类

虚基类关键字为`virtual`，构造方法与之前普通类相比有所不同，普通类中只存在即时构造函数，同时该构造函数可以将信息传往基类。比如：

```cpp
Student(string name, int age, string ID):Person(name, age){
    this->ID = ID;
}
```
而对于使用虚基类时，需要对类构造函数采用一种新的方法。虚基类中，